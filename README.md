# **Learning Projects**

Repositório com projetos feitos visando aprendizado e desenvolvimento de lógica. 

## Algoritmos nesse repositório

1. Ordenação por Seleção *(selection sort)*
2. Busca Binária *(binary search)*
3. Ordenação por Comparação *(quick sort)*
4. Lista Encadeada *(linked list)*
5. Funções Recursivas *(fatorial, conjunctura de collatz, algoritmo de euclides, entre outros exemplos práticos de recursividade)*

## 1. Ordenação por Seleção

O algoritmo de **ordenação por seleção** (em inglês: *selection sort*) é um método simples e intuitivo utilizado para ordenar uma lista de elementos.

A sua **complexidade**, no entanto, é *O(n²)*, o que torna-o menos eficiente quando comparado a outros algoritmos de ordenação, tais quais o *Quicksort* e o *Merge Sort*.

A base para o funcionamento do *selection sort* é encontrar o **menor valor** e então o colocar na **primeira posição da lista**. Depois, ele busca o **2° menor item** e o coloca na **segunda posição**, e assim sucessivamente.

> **Quer saber mais sobre o funcionamento do algoritmo de Ordenação por Seleção?** [Clique aqui](https://medium.com/@ricardo.davila.freitas/0b4806a90626) para acessar o meu artigo sobre o tema no **Medium**.

### 2. Busca Binária

A *binary search*, ou **busca binária**, é um algoritmo utilizado para encontrar um determinado elemento dentro de uma lista ordenada de itens.

Esse algoritmo recebe o seu nome devido a sua característica central: a **busca binária** divide a lista em *duas partes*, assim reduzindo as possibilidades de localização do item procurado **pela metade** a cada iteração do código.

> **Curioso sobre a lógica de funcionamento da Binary Search?** Confira meu artigo para saber mais : [Acesse aqui](https://medium.com/@ricardo.davila.freitas/algoritmo-de-busca-binária-binary-search-bbdd875d8ff3)


### 3. Ordenação por Comparação

O algoritmo **Quick Sort** é um dos mais eficientes para a ordenação de elementos.

A base para o seu funcionamento é o processo de **particionamento**, onde criam-se *partições* — ou "*subarrays*" — e reposiciona-se os elementos da lista com base no valor de um **pivô**. Assim sendo, o *Quick Sort* se dá através de uma série de **comparações** entre os elementos a serem ordenados.


Esse algoritmo recebe o seu nome devido a sua característica central: a **busca binária** divide a lista em *duas partes*, assim reduzindo as possibilidades de localização do item procurado **pela metade** a cada iteração do código.

> **Acesse meu artigo no Medium para saber mais;** Veja, passo a passo e de maneira didática, a construção do algortimo de Ordenação por Comparação : [Acesse aqui](https://medium.com/@ricardo.davila.freitas/algoritmo-quick-sort-ordena%C3%A7%C3%A3o-por-compara%C3%A7%C3%A3o-f5ccc3a4e231)
